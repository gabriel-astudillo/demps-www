<!-- Probado en 
                - Safari (MacOSX)
                - Chrome (MacOSX)

-->
<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
	<meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.4.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.4.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        body { margin:50; padding:0; }
        #map { 
			position:absolute; 
			top:30; 
			bottom:50; 
			width:90%;
			height: 80%; 
		}
    </style>
</head>
<body >
<div >
	<div>
		<button id="playBtn" style="float:left" onclick="play()" disabled>Play</button>
	</div>
	<div>
		<button style="float:left" onclick="stop()">Stop</button>
	</div>
	<div>
		<button style="float:left" onclick="resetPlay()">Reset</button>
	</div>
	<div>
		<button id="revBtn" style="float:left" onclick="backwardFrame()" disabled> Frame--</button>
	</div>
	<div>
		<button id="forwBtn" style="float:left" onclick="forwardFrame()" disabled>Frame++</button>
	</div>

	<div style="float:left">Nro Frame: </div><div id="frame" style="float:left"></div>
	
</div>

<br><br>

<div id='map'></div>


<script>
	mapboxgl.accessToken = 'pk.eyJ1IjoibGluZ2h1YW0iLCJhIjoiY2o1dWYzYzlqMDQ4OTJxbzRiZWl5OHdtcyJ9._Ae66CF7CGUIoJlVdrXjqA';
	
	// @@@@@@@ CAMBIAR ARCHIVO DE CONFIGURACIÓN SEGÚN CORRESPONDA @@@@@@@ 
	var configFile = "animacion.config.json";
	// @@@@@@@ ================================================== @@@@@@@ 
	
	// En 'configJson' se carga la configuración desde
	// el archivo definido en 'configFile'
	var configJson = loadConfig(configFile);
	
	//
	// Variables que se cargan desde 'config.json'
	//
	//==> Directorio que contiene los archivos de salida de la simulación.
	var pathFilesSim = configJson['pathFileSim'];

	//==> ID min y max de los frames a mostrar
	var frameMax = configJson['frameMax'];
	var frameMin = configJson['frameMin'];
	
	//==> separación de los timestep de los archivos de salida de la simualción
	var frameStep = configJson['frameStep'];
	
	//==> Region a mostar
	var areaFile = configJson['input']['area'];
	
	// En areaGeoJson['features'][0]['geometry']['coordinates'][0][x] ,
	// x={0,1,2,3} están los vértices del área de simulación
	var areaGeoJson = loadGeoJson(areaFile);
	
	var lat = [];
	var lon = [];
	for (var i = 0; i < 4; i++) {
		var coord = areaGeoJson['features'][0]['geometry']['coordinates'][0][i];
		lat[i] = coord[0];
		lon[i] = coord[1];
	}
	
	var latMax = Math.max.apply(null, lat);
	var latMin = Math.min.apply(null, lat);
	var lonMax = Math.max.apply(null, lon);
	var lonMin = Math.min.apply(null, lon);

	var centerMap = [(latMax+latMin)/2, (lonMax+lonMin)/2];
	
	var boundsMap = [
		[latMax, lonMin], // Southwest coordinates
		[latMin, lonMax]  // Northeast coordinates
	];
	
	var map = new mapboxgl.Map({

		container: 'map', // container id
		style: 'mapbox://styles/mapbox/streets-v9', //hosted style id
		//center : centerMap,
		//zoom: 10, // starting zoom
		
		bounds: boundsMap //The initial bounds of the map
		
	});

	
	var geoJson = {
	type: 'FeatureCollection',
	features: []
	};
	
	var geoJsonType2 = {
	type: 'FeatureCollection',
	features: []
	};
	
	map.on('load', function() {
		
		//Crea las estructuras GeoJson iniciales
		makeInitStruct();
		
		//Carga todos los frame
		makeAllFrame();
		
		//Hace el primer frame
		frameNumber = 0;
		makeFrame()
	});
	
	var nav = new mapboxgl.NavigationControl({
		showCompass: true,
		showZoom: true,
		visualizePitch: true
	});
	map.addControl(nav, 'top-left');
	
	var scale = new mapboxgl.ScaleControl({
	    maxWidth: 80,
	    unit: 'metric'
	});
	map.addControl(scale);



	var dot =  function(){
		return {
			type: "Feature",
			geometry: {
				type: "Point",
				coordinates: [0,0]
			}
		};
	};

	var dotsInFrame = [];
	var dotsType2InFrame = [];
	
	// ID del frame inicial
	var frameNumber=0;
	
	//Tiempo entre cada frame, en [ms]
	var stepFrame = 100;
	
	// Descriptor del timer que llama a la función loop()
	var interval;
	
	function loadConfig(configFile){
		//Solicitud sincrónica.
		// Ref: https://developer.mozilla.org/es/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
		
		var rawFile = new XMLHttpRequest();
		rawFile.open("GET", configFile, false);	
		rawFile.send(null);
		
		if (rawFile.status == 200){
			return( JSON.parse(rawFile.responseText) );
		}
		
	}
	
	function loadGeoJson(geoJsonFile){
		//Solicitud sincrónica.
		// Ref: https://developer.mozilla.org/es/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
		
		var rawFile = new XMLHttpRequest();
		rawFile.open("GET", geoJsonFile, false);	
		rawFile.send(null);
		
		if (rawFile.status == 200){
			return( JSON.parse(rawFile.responseText) );
		}
		
	}


	function drawDots(){ //GAM
		geoJson.features=dots;
		geoJsonType2.features = dots_type2;
		
		map.getSource('datos').setData(geoJson);
		map.getSource('datos_type2').setData(geoJsonType2);
		
	}

	function readSteps(){
		var IDfile = frameNumber.toString().padStart(10, "0");
		
		var file = pathFilesSim + IDfile + ".txt";
		
		var rawFile = new XMLHttpRequest();
		rawFile.open("GET", file, false);
		
		dotsInFrame[frameNumber] = [];
		dotsType2InFrame[frameNumber] = [];
		
		rawFile.onload = function(){
			var response=rawFile.responseText.split("\n").map(function(item){
				var array=item.split(" ");
				
				//Falta diferencia por tipo de agente.
				//Este está en array[3] ==> 0: shortesPath, 1: followTheCrowd, 2: ramdomWalk
				// --> Cada grupo de agentes en un layer distinto???

				if (array.length!=1){
					var newDot = new dot();
					if(array[3] == 0){
						newDot.geometry.coordinates=[parseFloat(array[2]), parseFloat(array[1])];
						dotsInFrame[frameNumber].push(newDot);
					}
					else if(array[3] == 2){
						newDot.geometry.coordinates=[parseFloat(array[2]), parseFloat(array[1])];
						dotsType2InFrame[frameNumber].push(newDot);
					}
					
				}
				
				array=null;
			});
		}
		rawFile.send(null);
		response=null;
	}
	
	function makeInitStruct(){ //GAM
		dots = []; 
		dots_type2 = [];
		
		geoJson.features=dots;
		geoJsonType2.features = dots_type2;
		
		//Source y layer para agentes tipo == 0
		map.addSource('datos',{
			"type": 'geojson',
			"data": geoJson
		});
		
		map.addLayer({
			"id": "points",
			"type": "circle",
			"source": 'datos',
			"paint": {
				"circle-radius": 1.5,
				"circle-color": "#FF0000"
			}
		});
		
		//Source y layer para agentes tipo == 2
		map.addSource('datos_type2',{
			"type": 'geojson',
			"data": geoJsonType2
		});
		
		map.addLayer({
			"id": "points_type2",
			"type": "circle",
			"source": 'datos_type2',
			"paint": {
				"circle-radius": 1.5,
				"circle-color": "#0000FF"
			}
		});
	}
	
	function makeAllFrame(){
		for (frameNumber = 0; frameNumber <= frameMax; frameNumber += frameStep) {		
			readSteps();
		}
		
		frameNumber = 0;
		
		document.getElementById("playBtn").disabled = false;
		document.getElementById("revBtn").disabled = false;
		document.getElementById("forwBtn").disabled = false;
	}
	
	
	function makeFrame(){ //GAM
		dots = []; 
		dots_type2 = [];
		
		dots = dotsInFrame[frameNumber];
		dots_type2 = dotsType2InFrame[frameNumber];
		
		
		var frameDiv = document.getElementById("frame");
		frameDiv.innerHTML = frameNumber;
		
		drawDots();

	}
	
	function forwardFrame(){ //GAM
		if(frameNumber < frameMax){
			frameNumber += frameStep;
			makeFrame(); 
		}
	}
	
	function backwardFrame(){ //GAM
		if(frameNumber > frameMin){
			frameNumber -= frameStep;
			makeFrame(); 
		}
	}
	
	function resetPlay(){
		frameNumber = frameMin;
		makeFrame(); 
	}

	function loop(){

		if (frameNumber<frameMax){
			
			frameNumber += frameStep;
			makeFrame(); //GAM
			
			//Cuando se utiliza requesetAnimationFrame,
			//no encontré la forma de controlar la velocidad
			//de actualización del frame
			
			//requestAnimationFrame(loop);
			
		}
		else{
			clearInterval(interval);
			dots=null;
			geoJson.features=null;
		}
			
		
		
		
	}

	function play(){
		if (dots.length!=0){
			//Forma A) utilizar setInterval()
			interval=setInterval(function(){
				loop();
			}, stepFrame);
				
			//Forma B Que la propia funcion se llame, utilizando
			//la funcion requestAnimationFrame() de MapBox
			//loop();
		}
	}
	
	function stop(){
		clearInterval(interval);
	}

</script>

</body>
</html>